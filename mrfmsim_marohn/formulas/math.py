"""Mathematical operations"""
import numpy as np
import numba as nb
from operator import sub


def create_func(name, expression):
    """Create a function from a string."""
    exec(expression, globals(), locals())
    func = locals()[name]
    return func


def numba_sum(args):
    """Create a summation function with numba jit decorator."""

    args_str = ", ".join(args)
    body = f"return {' + '.join(args)}"
    doc = f'"""Sum of {args_str}."""'
    expression = (
        f"def numba_sum({args_str}):"
        f"\n\t{doc}\n\t{body}"
    )
    func = create_func("numba_sum", expression)
    return nb.jit(nopython=True, parallel=True)(func)

def numba_sum_of_multiplication(args):
    """Create a summation of product function with numba jit decorator."""

    args_str = ", ".join(args)
    body = f"return np.sum({' * '.join(args)})"
    doc = f'"""Sum of the product of {args_str}."""'
    expression = (
        f"def numba_sum_of_multiplication({args_str}):"
        f"\n\t{doc}\n\t{body}"
    )
    func = create_func("numba_sum_of_multiplication", expression)
    return nb.jit(nopython=True, parallel=True)(func)

@nb.jit(nopython=True, parallel=True)
def sum_of_multiplication(a, b, c, d, e, f=1):
    """Summation of 5 matrices or scalar with a factor default to 1.

    To use numba jit, the compromise is to explicitly define the parameters,
    meaning we cannot define a function with an arbitrary number of parameters.
    The method is faster than reduce or other numpy tricks.

    """
    return np.sum(a * b * c * d * e * f)


def slice_matrix(matrix, shape):
    """Slice numpy matrix.

    The function only slice the matrix in the middle based on the shape.
    The resulting array should be a view of the original array,
    which provides memory and speed improvement.

    :param ndarray matrix: a numpy array.
    :param tuple shape: sliced shape, has the same dimension as the matrix.
        The shape along the sliced axis should be the same oddity as the matrix
    """

    oshape = np.array(matrix.shape)
    shape = np.array(shape)

    index_i = ((oshape - shape) / 2).astype(int)
    index_f = index_i + shape

    slice_index = []
    for i in range(shape.size):
        slice_index.append(slice(index_i[i], index_f[i]))

    return matrix[tuple(slice_index)]


def as_strided_x(dataset, window):
    """Function for adjusting the stride size in the x direction.

    The operation is very fast and does not require extra memory because it
    only defines the stride size rather than creating a new array
    For a dataset with a shape of (6, 5, 4) with a window of 3 in the x direction,
    the resulting array shape is (4, 5, 4). The two parameters new are
    (4, 6, 5, 4), stride is (160, 160, 32, 8) if each element is 2 bytes
    For example to determine the max value of a 3-dimensional array for every
    3 elements in x direction::
        dataset_strided = strided_axis0(dataset, 3)
        dataset_strided.max(axis = 1)
    For more information see:
        https://docs.scipy.org/doc/numpy/reference/generated/
        numpy.lib.stride_tricks.as_strided.html#numpy.lib.stride_tricks.as_strided
        https://www.jessicayung.com/numpy-arrays-memory-and-strides/

    :param array dataset: the dataset target to determine max and min
                        (or other running operations)
    :param int window: the size of a sliding window for the dataset
    :return: strided dataset
    :rtype: ndarray

    """

    new = (dataset.shape[0] - window + 1, window) + dataset.shape[1:]
    strides = (dataset.strides[0],) + dataset.strides

    return np.lib.stride_tricks.as_strided(
        dataset, shape=new, strides=strides, writeable=False
    )


def ogrid_sub(ogrid, cords):
    """Subtraction method used for ogrid.

    The operation is the same as:

    ogrid[0] - cords[0], ogrid[1] - cords[1], ...

    :param list ogrid: ogrid generated by np.ogrid
        ogrid needs to have at least 2 dimensions,
        otherwise ogrid returns an array instead of a list
    :param list cords: coordinates of a point
        the dimension should be the same as ogrid
    :return: ogrid
    """

    return list(map(sub, ogrid, cords))
