"""Mathematical operations"""
import numpy as np
import numba as nb
from operator import sub


@nb.jit(nopython=True, parallel=True)
def hex_mul_sum(a, b, c, d, e, sign=1):
    """Summation of 5 matrices or scalar with a sign

    To use numba jit, the compromise is to explicitly define the parameters,
    meaning we cannot define a function with arbitrary number of parameters.
    The method is faster than reduce or other numpy tricks.

    """
    return sign * np.sum(a * b * c * d * e)


def slice_matrix(matrix, shape):
    """Slice numpy matrix

    The function only slice the matrix in the middle based on the shape.
    The resulting array should be a view of the original array,
    which provides memory and speed improvement.

    :param ndarray matrix: a numpy array.
    :param tuple shape: sliced shape, has the same dimension as the matrix.
        The shape along the sliced axis should be the same oddity as the matrix
    """

    oshape = np.array(matrix.shape)
    shape = np.array(shape)

    index_i = ((oshape - shape) / 2).astype(int)
    index_f = index_i + shape

    slice_index = []
    for i in range(shape.size):
        slice_index.append(slice(index_i[i], index_f[i]))

    return matrix[tuple(slice_index)]


def as_strided_x(dataset, window):
    """This is the function for adjusting the stride size in x direction
    The operation is very fast and does not require extra memory because it
    only defines the stride size rather than creating a new array
    For a dataset with a shape of (6, 5, 4) with a window of 3 in x direction,
    the resulting array shape is (4, 5, 4). The two parameters new is
    (4, 6, 5, 4), stride is (160, 160, 32, 8), if each element is 2 bytes
    For example to determine the max value of an 3 dimensional array for every
    3 elements in x direction::
        dataset_strided = strided_axis0(dataset, 3)
        dataset_strided.max(axis = 1)
    For more information see:
        https://docs.scipy.org/doc/numpy/reference/generated/
        numpy.lib.stride_tricks.as_strided.html#numpy.lib.stride_tricks.as_strided
        https://www.jessicayung.com/numpy-arrays-memory-and-strides/
    :param array dataset: the dataset target to determine max and min
                        (or other running operations)
    :param int window: the size of a sliding window for the dataset
    :return: strided dataset
    :rtype: ndarray
    """

    new = (dataset.shape[0] - window + 1, window) + dataset.shape[1:]
    strides = (dataset.strides[0],) + dataset.strides

    return np.lib.stride_tricks.as_strided(
        dataset, shape=new, strides=strides, writeable=False
    )


def ogrid_sub(ogrid, cords):
    """Subtraction method used for ogrid

    The operation is the same as:

    ogrid[0] - cords[0], ogrid[1] - cords[1], ...

    :param list ogrid: ogrid generated by np.ogrid
        ogrid needs to have at least 2 dimensions,
        otherwise ogrid returns an array instead of a list
    :param list cords: coordinates of a point
        the dimension should be the same as ogrid
    :return: ogrid
    """

    return list(map(sub, ogrid, cords))


def ogrid_method(method, ogrid):
    """Used ogrid for the method.

    See ogrid documentation here
    https://numpy.org/doc/stable/reference/generated/numpy.ogrid.html
    Returns a broadcasted mesh result.

    :param callable method: method that takes coordinates as arguments
    :param list ogrid: ogrid generated by np.ogrid
        or a iterable generated by mapping, see ogrid_sub
        the dimensions should match the method
    """

    return method(*ogrid)
